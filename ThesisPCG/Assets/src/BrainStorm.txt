TODO

hot observable of propagator is triggered but the first value is lost, can be fixed with dummy first 

for inspiration http://stackoverflow.com/questions/8083357/adding-an-observable-sequence-after-subscription

test propagator and refactor code for reuse of source and target code as much as possible

implement default parameter with functional consume Parameters



only return one instance of observable for each cycle of the dataflow graph
cache if needed


create wrapper class for arrayparameter and matrix parameter as they have different

http://leecampbell.blogspot.be/2010/08/rx-part-7-hot-and-cold-observables.html

gebruik (multicast, subject)

instead of saveing the soruces in the target save only the link


add a repeat mode (alternating, copy,...) to a source

add Builder pattern to construct the different types of configures source nodes



for target node make set as inputParameters instead of dictionary

create differen classes for parameters as ports and parameters as values

allow parameter constructor with default value

values without default have to be linked, check this


try to find a solution for compile time checkign of parameter names, please


//this will be used for backtracking later in edit propagation
			// a blackbox parameters is processed inside the generator node and the process' result is assigned to a generators result propery
			//a whitebox parameter is immutable and is directly linked to the generators result property
			//if a parameters weight as input is a scalar that reflects it's amount of influence in the output it is white box
			//data can be blackbox too, for example a simulated population that output its varying properties based on input parameters
			/*	public enum Type
		{
			BLACKBOX,
			WHITEBOX
		}*/


		TODO implement similarly to Parameter (hidden generics) also TupelParameter and 2DParameter
		and sourceNode as well


		step by step introduce generics that bubble from ISubject to Iparameter to ISourceNode 

		generics would be possible if working with Tuples instead of dictionaries
		This would result in a fixed amount of parameters at compile time, which isn't neccesarly a problem


		ITarget<T>
		ISource<T>

		T->Tuple<T1,T2,T3,...>
