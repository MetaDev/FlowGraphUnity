TODO


only create different stream in source node if the requested size is different -> remove size but use interpolation or error on imcompatible size

move project to project folder in drive

throw warning when trying to change linke between nodes

ask rian about crash

on linkto of target node check at run time the order of the parameters

create a seperate class called ParameterType that is a parameter without values
and rename to other to ParameterWrapper

->try to work with immutable objects, especially the parameters

add a method dimension to the parameters, as the dimensions of parameters should match too
Parameter can be a multidimensional vector

try to throw the possible class cast exception in a parameter verbally

test propagator and refactor code for reuse of source and target code as much as possible

implement default parameter with functional consume Parameters, if an input parameter has only 1 value
set the parameter to cached and no longer call AsObservable on it in the link to

add a repeat mode (alternating, copy,interpolate...) to a source of length >1


for target node make set as inputParameters instead of dictionary

create differen classes for parameters as ports and parameters as values



//this will be used for backtracking later in edit propagation
			// a blackbox parameters is processed inside the generator node and the process' result is assigned to a generators result propery
			//a whitebox parameter is immutable and is directly linked to the generators result property
			//if a parameters weight as input is a scalar that reflects it's amount of influence in the output it is white box
			//data can be blackbox too, for example a simulated population that output its varying properties based on input parameters
			/*	public enum Type
		{
			BLACKBOX,
			WHITEBOX
		}*/


		TODO implement similarly to Parameter (hidden generics) also TupelParameter and 2DParameter
		and sourceNode as well


		step by step introduce generics that bubble from ISubject to Iparameter to ISourceNode 

		generics would be possible if working with Tuples instead of dictionaries
		This would result in a fixed amount of parameters at compile time, which isn't neccesarly a problem


		ITarget<T>
		ISource<T>

		T->Tuple<T1,T2,T3,...>
